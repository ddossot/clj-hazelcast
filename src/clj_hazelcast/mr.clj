(ns clj-hazelcast.mr
  (:import (com.hazelcast.mapreduce Mapper Reducer ReducerFactory KeyValueSource Combiner CombinerFactory Collator)
           (com.hazelcast.core ExecutionCallback)
           (java.util.concurrent TimeUnit))
  (:require [clj-hazelcast.core :as hazelcast]
            [clojure.tools.logging :as log]))

(defn emit-mapped-pairs [pairs collector]
  (doall
    (map #(do
           (log/debugf "emitting pair: %s" %1)
           (let [emit-key (first %1)
                 emit-value (second %1)]
             (log/debugf "emitting key: %s emit vlaue: %s " emit-key emit-value)
             (.emit collector emit-key emit-value)
             ))
         pairs))
  )

(defn- hmap
  "runs the function f over the content

  f is a function of two arguments, key and value.

  f must return a sequence of *pairs* like
   [[key1 value1] [key2 value2] ...]
  "
  [f]
  (proxy
      [Mapper] []
    (map [k v collector]
      (let [pair-seq (f k v)]
        (emit-mapped-pairs pair-seq collector)
        )
      )))


(defn- hreducefactory
  "runs the reducer function rf over the content

  rf is a function of two arguments, value and an atom containing the state

  state does contain the key:

  {:key key
   :val val}

  rf should set the val eventually
  "
  [f]
  (proxy [ReducerFactory] []
    (newReducer [key]
      (let [state (atom nil)]
        (proxy
            [Reducer] []
          (beginReduce [k]
            (do
              (log/debugf "beginReduce with %s" k)
              (reset! state {:key k}))
            )
          (reduce [v]
            (do
              (log/debugf "reduce with %s" v)
              (f v state))
            )
          (finalizeReduce []
            (do
              (log/debugf "finalizeReduce")
              (:val @state))))))))

(defn- hcombinerfactory
  "runs the combiner function cf over the content

  cf is a function of two arguments, value and an atom containing the state

  {:val val}

  rf should set the val eventually
  "
  [f]
  (proxy [CombinerFactory] []
    (newCombiner [key]
      (log/debugf "newCombiner instance for key: %s " key)
      (let [state (atom {:key key})]
        (proxy
            [Combiner] []
          (combine [k v]
            (do
              (log/debugf "combine with key: %s value: %s" k v)
              (f v state)))
          (finalizeChunk []
            (let [ret-val (:val @state)]
              (log/debugf "finalizeChunk")
              (reset! state {:key key})))))))
  )

(defn hcollator
  "
  runs the collactor function f over the content

  f is a function of one argument, a sequence of Entry objects,
  where Entry's are generated by the reducers output:

  [Entry1 Entry2 ...]
  "
  [f]
  (proxy [Collator] []
    (collate [pairs]
      ;(log/debugf "Collating %s " pairs)
      ;(log/debugf "Collating %s " (class pairs))
      (f (iterator-seq (.iterator pairs)))
      )
    )
  )


(defn make-job-tracker [hz-instance]
  (.getJobTracker hz-instance "default")
  )

(defn submit-job "returns the future object from Hazelcast Mapreduce Api"
  [{:keys [map mapper-fn combiner-fn reducer-fn collator-fn tracker]}]
  (let [src (KeyValueSource/fromMap map)
        mapper (hmap mapper-fn)
        reducer (hreducefactory reducer-fn)
        job (atom (-> (.newJob tracker src)
                      (.mapper mapper)))]
    (log/debugf "Submitting new MR Job ...")
    (if-not (nil? combiner-fn)
      (do
        (log/debugf "No Combiner defined for job...")
        (reset! job (-> @job
                        (.combiner (hcombinerfactory combiner-fn)))))
      )
    (if-not (nil? collator-fn)
      (do
        (log/debugf "No Collator defined for job...")
        (reset! job (-> @job
                        (.reducer reducer)
                        (.submit (hcollator collator-fn)))))
      (reset! job (-> @job
                      (.reducer reducer)
                      (.submit))))

    (.andThen @job (proxy [ExecutionCallback] []
                     (onResponse [res]
                       (log/debugf "Calculation finished %s" res))
                     (onFailure [t]
                       (.printStackTrace t))))
    (log/debugf "Callback registered ...")
    (.get @job 2 TimeUnit/SECONDS)
    ))

