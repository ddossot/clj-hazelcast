(ns clj-hazelcast.mr
  (:import (com.hazelcast.mapreduce Mapper Reducer ReducerFactory KeyValueSource Combiner CombinerFactory Collator)
           (com.hazelcast.core ExecutionCallback))
  (:require [clj-hazelcast.core :as hazelcast]
            [clojure.tools.logging :as log]))

(defn emit-mapped-pairs [pairs collector]
  (doall
    (map #(do
           (log/debugf "emitting pair: %s" %1)
           (let [emit-key (first %1)
                 emit-value (second %1)]
             (log/debugf "emitting key: %s emit vlaue: %s " emit-key emit-value)
             (.emit collector emit-key emit-value)))
         pairs)))

(defn- hmap
  "runs the function f over the content

  f is a function of two arguments, key and value.

  f must return a sequence of *pairs* like
   [[key1 value1] [key2 value2] ...]
  "
  [f]
  (proxy
      [Mapper] []
    (map [k v collector]
      (let [pair-seq (f k v)]
        (if-not (coll? pair-seq)
          (do
            (log/errorf "Bad Mapper Function, returned result is not a Collection %s " pair-seq)
            (throw (RuntimeException. "Bad Mapper function, should return a collection")))
          (do
            (log/debugf "Mapper Returned :%s " (class pair-seq))
            (emit-mapped-pairs pair-seq collector)))))))


(defn- hreducefactory
  "runs the reducer function rf over the content

  rf is a function of three arguments,

  key,value and acc

  rf should return the accumulated result.
  "
  [f initial-accumulator-value]
  (proxy [ReducerFactory] []
    (newReducer [key]
      (let [acc (atom {:value initial-accumulator-value})]
        (proxy
            [Reducer] []
          (beginReduce [k]
            (do
              (log/debugf "beginReduce with %s" k)
              (swap! acc assoc :key k))
            )
          (reduce [v]
            (do
              (log/debugf "reduce with %s" v)
              (let [reduced (f (:key @acc) v (:value @acc))]
                (if-not (nil? reduced)
                  (swap! acc assoc :value reduced)
                  (do
                    (log/errorf "Bad Reducer function, should set :val to acc : %s" @acc)
                    (throw (RuntimeException. "Bad Reducer function, should set :val to acc")))))))
          (finalizeReduce []
            (let [ret-val (:value @acc)]
              (log/debugf "finalizeReduce")
              (reset! acc {:value initial-accumulator-value})
              ret-val)))))))

(defn- hcombinerfactory
  "runs the combiner function cf over the content

  cf is a function of three arguments,

  key,value and acc

  cf should set the val eventually
  "
  [f initial-accumulator-value]
  (proxy [CombinerFactory] []
    (newCombiner [key]
      (log/debugf "newCombiner instance for key: %s " key)
      (let [acc (atom {:value initial-accumulator-value})]
        (proxy
            [Combiner] []
          (combine [k v]
            (let [combined (f k v (:value @acc))]
              (log/debugf "combined with key: %s value: %s" k v)
              (swap! acc assoc :value combined)))
          (finalizeChunk []
            (let [ret-val (:value @acc)]
              (log/debugf "finalizeChunk with value %s " ret-val)
              (reset! acc {:value initial-accumulator-value})
              ret-val)))))))

(defn hcollator
  "
  runs the collactor function f over the content

  f is a function of one argument, a sequence of Entry objects,
  where Entry's are generated by the reducers output:

  [Entry1 Entry2 ...]
  "
  [f]
  (proxy [Collator] []
    (collate [pairs]
      ;(log/debugf "Collating %s " pairs)
      ;(log/debugf "Collating %s " (class pairs))
      (f (iterator-seq (.iterator pairs))))))


(defn make-job-tracker [hz-instance]
  (.getJobTracker hz-instance "default"))

(defn submit-job "returns the future object from Hazelcast Mapreduce Api"
  [{:keys [map mapper-fn combiner-fn combiner-acc reducer-fn reducer-acc collator-fn tracker]}]
  (let [src (KeyValueSource/fromMap map)
        mapper (hmap mapper-fn)
        reducer (hreducefactory reducer-fn reducer-acc)
        job (atom (-> (.newJob tracker src)
                      (.mapper mapper)))]
    (log/debugf "Submitting new MR Job ...")
    (if-not (nil? combiner-fn)
      (do
        (log/debugf "No Combiner defined for job...")
        (reset! job (-> @job
                        (.combiner (hcombinerfactory combiner-fn combiner-acc)))))
      )
    (if-not (nil? collator-fn)
      (do
        (log/debugf "No Collator defined for job...")
        (reset! job (-> @job
                        (.reducer reducer)
                        (.submit (hcollator collator-fn)))))
      (reset! job (-> @job
                      (.reducer reducer)
                      (.submit))))

    (.andThen @job (proxy [ExecutionCallback] []
                     (onResponse [res]
                       (log/debugf "Calculation finished %s" res))
                     (onFailure [t]
                       (.printStackTrace t))))
    (log/debugf "Callback registered ...")
    @job))

