# Clj-hazelcast

Clojure library for Hazelcast, an open source clustering and highly scalable data distribution
platform for Java.

# TravisCI Status

[![Build Status](https://travis-ci.org/runa-labs/clj-hazelcast.png)](https://travis-ci.org/runa-labs/clj-hazelcast)

# Usage

Clj hazelcast comes preconfigured out of the box and allows adding members as an option.
For example, The init function takes a map, {:peers [hostname1 hostname2 ...]}, 
and starts a peer node on them as the member of the cluster.

This library supports synchronization of clj-kryo (another open source library 
from Runa labs) serializable data structures across network. It also supports 
event driven communication among them. A typical use case would to sync key/value
pair among the peers. For example:

Suppose you have following data in all nodes:   (def test-map (atom nil))
You can put new values to this map on host 1:   (hazelcast/put! @test-map :baz "foobar")

Then you can retrieve "foobar" from host 2:    (:baz (hazelcast/get-map "your.name.space.test-map"))

Furthermore, you can add listener to that data to perform all sorts of callbacks. 
For example:

```clj
(let [events (atom [])
      listener-fn (fn [& event]
                    (swap! events conj event))
      listener (hazelcast/add-entry-listener! @test-map listener-fn)
      result (do
               (hazelcast/put! @test-map :baz "foobar")
               (hazelcast/put! @test-map :foo "bizbang")
               (Thread/sleep 5)
               (count @events))]
  (hazelcast/remove-entry-listener! @test-map listener)
  result)
```

Please refer to the inlcuded test for more detail.

#Using the MapReduce Framework
The namespace **clj-hazelcast.mr** contains an abstraction to make it easier when dealing with mapreduce jobs.

##Mapper
Runs the function f over the content. <br>
f is a function of two arguments: **key** and **value**. <br>
f must return a sequence of *pairs* like

	[[key1 value1] [key2 value2] ...]
	  
Sample Mapper

	(fn [k v] [[k (+ 1 v)])

This is a simple mapper that gets each key-value pair and returns a pair of k and value+1

	
##Reducer 
Runs the reducer function rf over the content. <br>
rf is a function of two arguments, value and an atom containing the state. (You can check the related Hazelcast Documentation to see why this is implemented this way)<br>
State is a map, and contains the **:key** of the reduced pair: <br>
	
	{:key key :val val}

rf should set the **:val** eventually. This is how you would pass the computed value out of the reducer.

Sample Reducer
  
		(fn [v state] 
			(let [old @state]
             (if-not (nil? (:val old))
                (reset! state (assoc old :val (inc (:val old))))
                (reset! state (assoc old :val 1)))))

This is a simple reducer that counts unique occurences of each key.

##Collator

Runs the collactor function f over the content.<br>
f is a function of one argument, a sequence of Entry objects,
where Entry's are generated by the reducers output:

	[Entry1 Entry2 ...]

##Combiner

Combiners are mostly the same as the reducers

##Wordcount Example
Check 'clj-hazelcast.test.mr-test


## License

 *   The use and distribution terms for this software are covered by the
 *   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
 *   which can be found in the file epl-v10.html at the root of this distribution.
 *   By using this software in any fashion, you are agreeing to be bound by
 *   the terms of this license.
 *   You must not remove this notice, or any other, from this software.
